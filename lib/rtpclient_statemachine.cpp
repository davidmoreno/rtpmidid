// This is an autogenerated file. It should be included at source
void rtpclient_t::handle_event(event_e event){
    state_e oldstate = state;
    state = state_e::Error;
    switch(oldstate){
        case state_e::Error:
            switch(event){
                case event_e::Connect:
                    state = state_e::PrepareNextDNS;
                    break;
            default:;
            }
            break;
        case state_e::WaitToStart:
            switch(event){
                case event_e::Started:
                    state = state_e::PrepareNextDNS;
                    break;
            default:;
            }
            break;
        case state_e::PrepareNextDNS:
            switch(event){
                case event_e::NextReady:
                    state = state_e::ResolveNextIpPort;
                    break;
                case event_e::ResolveListExhausted:
                    state = state_e::Error;
                    break;
            default:;
            }
            break;
        case state_e::ResolveNextIpPort:
            switch(event){
                case event_e::ConnectListExhausted:
                    state = state_e::PrepareNextDNS;
                    break;
                case event_e::ResolveFailed:
                    state = state_e::ResolveNextIpPort;
                    break;
                case event_e::Resolved:
                    state = state_e::ConnectControl;
                    break;
            default:;
            }
            break;
        case state_e::ConnectControl:
            switch(event){
                case event_e::ConnectFailed:
                    state = state_e::ResolveNextIpPort;
                    break;
                case event_e::Connected:
                    state = state_e::ConnectMidi;
                    break;
            default:;
            }
            break;
        case state_e::ConnectMidi:
            switch(event){
                case event_e::Connected:
                    state = state_e::AllConnected;
                    break;
                case event_e::ConnectFailed:
                    state = state_e::DisconnectControl;
                    break;
            default:;
            }
            break;
        case state_e::AllConnected:
            switch(event){
                case event_e::SendCK:
                    state = state_e::SendCkShort;
                    break;
            default:;
            }
            break;
        case state_e::DisconnectControl:
            switch(event){
                case event_e::ConnectFailed:
                    state = state_e::ResolveNextIpPort;
                    break;
            default:;
            }
            break;
        case state_e::SendCkShort:
            switch(event){
                case event_e::WaitSendCK:
                    state = state_e::WaitSendCkShort;
                    break;
                case event_e::LatencyMeasured:
                    state = state_e::WaitSendCkLong;
                    break;
                case event_e::Timeout:
                    state = state_e::DisconnectBecauseCKTimeout;
                    break;
            default:;
            }
            break;
        case state_e::WaitSendCkShort:
            switch(event){
                case event_e::SendCK:
                    state = state_e::SendCkShort;
                    break;
            default:;
            }
            break;
        case state_e::WaitSendCkLong:
            switch(event){
                case event_e::SendCK:
                    state = state_e::SendCkLong;
                    break;
            default:;
            }
            break;
        case state_e::DisconnectBecauseCKTimeout:
            switch(event){
                case event_e::ConnectFailed:
                    state = state_e::ConnectControl;
                    break;
            default:;
            }
            break;
        case state_e::SendCkLong:
            switch(event){
                case event_e::WaitSendCK1:
                    state = state_e::WaitSendCkLong;
                    break;
                case event_e::Timeout:
                    state = state_e::DisconnectBecauseCKTimeout;
                    break;
            default:;
            }
            break;
    }
    switch(state){
        case state_e::Error:
            state_error();
            break;
        case state_e::WaitToStart:
            state_wait_to_start();
            break;
        case state_e::PrepareNextDNS:
            state_prepare_next_dns();
            break;
        case state_e::ResolveNextIpPort:
            state_resolve_next_ip_port();
            break;
        case state_e::ConnectControl:
            state_connect_control();
            break;
        case state_e::ConnectMidi:
            state_connect_midi();
            break;
        case state_e::AllConnected:
            state_all_connected();
            break;
        case state_e::DisconnectControl:
            state_disconnect_control();
            break;
        case state_e::SendCkShort:
            state_send_ck_short();
            break;
        case state_e::WaitSendCkShort:
            state_wait_send_ck_short();
            break;
        case state_e::WaitSendCkLong:
            state_wait_send_ck_long();
            break;
        case state_e::DisconnectBecauseCKTimeout:
            state_disconnect_because_cktimeout();
            break;
        case state_e::SendCkLong:
            state_send_ck_long();
            break;
    }
}
// event formatter
const char *rtpclient_t::to_string(rtpclient_t::event_e value) {
    switch (value) {
    case rtpclient_t::event_e::Started:
        return "Started";
    case rtpclient_t::event_e::NextReady:
        return "NextReady";
    case rtpclient_t::event_e::ResolveListExhausted:
        return "ResolveListExhausted";
    case rtpclient_t::event_e::ConnectListExhausted:
        return "ConnectListExhausted";
    case rtpclient_t::event_e::ResolveFailed:
        return "ResolveFailed";
    case rtpclient_t::event_e::Resolved:
        return "Resolved";
    case rtpclient_t::event_e::ConnectFailed:
        return "ConnectFailed";
    case rtpclient_t::event_e::Connected:
        return "Connected";
    case rtpclient_t::event_e::SendCK:
        return "SendCK";
    case rtpclient_t::event_e::WaitSendCK:
        return "WaitSendCK";
    case rtpclient_t::event_e::LatencyMeasured:
        return "LatencyMeasured";
    case rtpclient_t::event_e::Timeout:
        return "Timeout";
    case rtpclient_t::event_e::WaitSendCK1:
        return "WaitSendCK1";
    case rtpclient_t::event_e::Connect:
        return "Connect";
    default:
            return "unknown";
    }  
}
// state formatter
const char *rtpclient_t::to_string(rtpclient_t::state_e value) {
    switch (value) {
    case rtpclient_t::state_e::Error:
        return  "Error";
    case rtpclient_t::state_e::WaitToStart:
        return  "WaitToStart";
    case rtpclient_t::state_e::PrepareNextDNS:
        return  "PrepareNextDNS";
    case rtpclient_t::state_e::ResolveNextIpPort:
        return  "ResolveNextIpPort";
    case rtpclient_t::state_e::ConnectControl:
        return  "ConnectControl";
    case rtpclient_t::state_e::ConnectMidi:
        return  "ConnectMidi";
    case rtpclient_t::state_e::AllConnected:
        return  "AllConnected";
    case rtpclient_t::state_e::DisconnectControl:
        return  "DisconnectControl";
    case rtpclient_t::state_e::SendCkShort:
        return  "SendCkShort";
    case rtpclient_t::state_e::WaitSendCkShort:
        return  "WaitSendCkShort";
    case rtpclient_t::state_e::WaitSendCkLong:
        return  "WaitSendCkLong";
    case rtpclient_t::state_e::DisconnectBecauseCKTimeout:
        return  "DisconnectBecauseCKTimeout";
    case rtpclient_t::state_e::SendCkLong:
        return  "SendCkLong";
    default:        return  "unknown";
    }
}
